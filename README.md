# home-owner-insurance

## Dependencies

- Python 3.10
- Docker
- PostgreSQL

## Local Development Setup

1. Install Docker Desktop
   - https://docs.docker.com/desktop/
2. Install PostregSQL
   - https://www.postgresql.org/download/
3. Setup Python
   - https://www.python.org/downloads/release/python-3109/
4. Setup virtual environment
   - https://github.com/pyenv/pyenv
   - https://docs.python.org/3.10/library/venv.html
5. Install libraries from requirements.txt & requirements-dev.txt
   - `pip install -r requirements.txt`
   - `pip install -r requirements-dev.txt`
6. Install `pre-commit` hooks
   - `pre-commit install`



## Steps to run application

1. Launch Docker Desktop
2. Open a terminal/command prompt
3. Navigate to the project root directory in the terminal/command prompt
4. Run the command `docker-compose build`
5. Run the command `docker-compose run --rm app sh -c "python manage.py test"` to run tests for the project
6. Run the command `docker-compose up` to run the server
7. To shut-down the server, enter `Ctrl + C` or `CMD + C` in the terminal/command prompt
8. Run the command `docker-compose down` to remove artifacts generated by Docker when running the server


## Steps to test the Swagger API when the server is running
1. Open a browser and navigate to the Swagger API Docs
   - http://localhost:8000/api/docs/
2. Create a User via the `POST /api/user/create/` endpoint
3. Create a User Token via the `POST /api/user/token/` endpoint
4. Copy the token and navigate to the top right of the browser and click `Authorize`
5. In the `tokenAuth (apiKey)` section, enter the value:
    - Token <paste token>
    - Click `Authorize`
6. Now you can access the other endpoints as an authenticated user



## `docker-compose` commands

- Upon updating the Dockerfile, be sure to build the Docker container
```
docker-compose build
```
- Run application using Docker
```
docker-compose up
```
- Tear down any artifacts from Docker
```
docker-compose down
```
- Run application's tests
```
docker-compose run --rm app sh -c "python manage.py test"
```

## Product Enhancements for additional phases
- Setup an expiration date for previously quoted prices
   - This will allow for old quotes to be refreshed in the event coverage costs change
   - Implementing an expiration will inform consumers that the provided price is no longer guaranteed after a certain date rather than retroactively updating all quotes in the event of a coverage cost change.
   - This quotes can be updated via a CronJob that's run daily to pick up all quotes with an expiration date of today and refresh the price.
- Introducing other types of cost coverages
   - Current cost coverages include
     - Flat Cost
     - Percentage Cost off the subtotal
   - Examples
      - Multiplicative cost for each pet
      - Percentage cost of a collection of other coverages


## Design considerations
- Intentional design to stray away from the consideration: `The individual variables for the pricing algorithm should be easy to modify, ideally without changing or deploying new code. For example, updating flood coverage in New York from 10% to 20% should be a simple task.`
   - The current system is designed to calculate the cost of a quote upon creation of a new Quote. The system keep the cost calculation values in the code base rather than having it persist in the database where it can be modifiable on demand. Reasons for this include:
     - Changes that would impact existing quotes and client facing consumers should be part of the development cycle so that product and engineering can collaborate on how to properly release the pricing changes.
       - Coordinating a backfill of existing quotes
       - Announcement to existing customers with a pending quote
     - Changing pricing rules would break existing tests that are evaluating the output of the pricing algorithm and would require a code change.
- Performing math in Python can have errors on rounding due to Python's floating point error
   - Some measures implemented to reduce this error:
     - `floor(val * 100) / 100` to drop any numbers past 2 decimals
     - `Decimal` class to force a 2-point precision in the database
